<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zcwww.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Java集合">
<meta property="og:url" content="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="THIS IS B3c0me">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/u=1818462379,1415696030&fm=253&fmt=auto&app=138&f=JPEG.jpeg">
<meta property="og:image" content="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/image-20231007084533120.png">
<meta property="og:image" content="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/image-20231007084934588.png">
<meta property="og:image" content="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/image-20231007094910849.png">
<meta property="article:published_time" content="2023-10-07T00:26:53.000Z">
<meta property="article:modified_time" content="2023-10-09T00:46:57.050Z">
<meta property="article:author" content="B3c0me">
<meta property="article:tag" content="学习 生活 分享 交流">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/u=1818462379,1415696030&fm=253&fmt=auto&app=138&f=JPEG.jpeg">

<link rel="canonical" href="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java集合 | THIS IS B3c0me</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">THIS IS B3c0me</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zcwww6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zcwww.top/2023/10/07/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="B3c0me">
      <meta itemprop="description" content="去爱 去工作">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THIS IS B3c0me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java集合
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-07 08:26:53" itemprop="dateCreated datePublished" datetime="2023-10-07T08:26:53+08:00">2023-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-09 08:46:57" itemprop="dateModified" datetime="2023-10-09T08:46:57+08:00">2023-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%91%95%E5%BF%83%E6%B2%A5%E8%A1%80%E5%AD%A6JAVA/" itemprop="url" rel="index"><span itemprop="name">呕心沥血学JAVA</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="/2023/10/07/Java%E9%9B%86%E5%90%88/u=1818462379,1415696030&fm=253&fmt=auto&app=138&f=JPEG.jpeg" alt="img"></p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p>1.<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_55133453/article/details/124476889">https://blog.csdn.net/qq_55133453/article/details/124476889</a></p>
<p>2.<a target="_blank" rel="noopener" href="https://blog.csdn.net/zdl66/article/details/126251818">https://blog.csdn.net/zdl66/article/details/126251818</a></p>
<p>3.<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_64314142/article/details/130490393">https://blog.csdn.net/weixin_64314142/article/details/130490393</a></p>
<p>感谢原创作者</p>
<h1 id="一、Java集合框架概述"><a href="#一、Java集合框架概述" class="headerlink" title="一、Java集合框架概述"></a>一、Java集合框架概述</h1><p>​    面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以<strong>动态</strong>地把多个对象的引用放入容器中。</p>
<h2 id="1-1-数组Array存储"><a href="#1-1-数组Array存储" class="headerlink" title="1.1 数组Array存储"></a>1.1 数组Array存储</h2><p>（1）数组在内存<strong>存储方面的特点</strong> ：</p>
<ul>
<li><p>数组初始化以后，<strong>长度就确定</strong>了。</p>
</li>
<li><p>数组<strong>声明的类型</strong>，就决定了进行元素初始化的类型。</p>
</li>
</ul>
<p>（2）数组在存储数据方面的<strong>弊端</strong>：</p>
<ul>
<li><p>数组初始化以后，长度就不可变了，不便于拓展。</p>
</li>
<li><p>数组中提供的<strong>属性和方法少，</strong>不便于进行添加、删除、插入等操作，且效率不高。同时<strong>无法直接获取存储元素的个数</strong>。</p>
</li>
</ul>
<ul>
<li>数组存储的<strong>数据是有序的、可以重复的</strong>。—-&gt;存储数据的特点单一。</li>
</ul>
<h2 id="1-2-Java集合类存储"><a href="#1-2-Java集合类存储" class="headerlink" title="1.2  Java集合类存储"></a>1.2  Java集合类存储</h2><p>​    Java集合类可以用于存储数量不等的多个<strong>对象</strong>，还可以用于保存具有<strong>映射关系</strong>的关联数组。</p>
<h2 id="1-3-Java集合体系"><a href="#1-3-Java集合体系" class="headerlink" title="1.3 Java集合体系"></a>1.3 Java集合体系</h2><ul>
<li><p><strong>Collection接口</strong></p>
<p>单列数据，定义了存取一组对象的方法的集合</p>
</li>
</ul>
<p>​    ①List：元素<strong>有序、可重复</strong>的集合</p>
<p>​    ②Set：元素<strong>无序、不可重复</strong>的集合</p>
<p>（2）<strong>Map接口</strong><br>        双列数据，保存具有映射关系“key-value对”的集合。</p>
<h2 id="1-4-Collection继承树"><a href="#1-4-Collection继承树" class="headerlink" title="1.4 Collection继承树"></a>1.4 Collection继承树</h2><p><img src="/2023/10/07/Java%E9%9B%86%E5%90%88/image-20231007084533120.png"></p>
<ul>
<li>List特点：此处顺序并不是大小顺序，而是存入数据的先后顺序。有序因为List集合都有下标，下标从0开始，以递增。</li>
</ul>
<ul>
<li>Set特点：取出顺序不一定为存入顺序，另外Set集合没有下标。</li>
</ul>
<ul>
<li>ArrayList是非线程安全的。</li>
</ul>
<ul>
<li>HashSet集合在new的时候，底层实际上new了一个HashMap集合。向HashSet集合中存储元素，实际上是存储到了HashMap的key中了。HashMap集合是一个Hash表数据结构。</li>
</ul>
<ul>
<li><p>TreeSet集合底层实际上是TreeMap。TreeSet集合在new的时候，底层实际上new了一个TreeMap集合。向TreeSet集合中存储元素，实际上是存储到了TreeMap的key中了。TreeMap集合是一个二叉树数据结构。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|<span class="comment">----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line">     |<span class="comment">----List接口：一种包含有序元素的线性表，可存储有序的、可重复的数据。</span></span><br><span class="line">                    可以存放多个<span class="keyword">null</span>值。      <span class="comment">--&gt;“动态”数组</span></span><br><span class="line">           |<span class="comment">----ArrayList：作为List接口的主要实现类,多用于频繁的改查操作,线程不安全的,效率高;</span></span><br><span class="line">                           底层采用<span class="keyword">Object</span>[] elementData数组存储。</span><br><span class="line">           |<span class="comment">----LinkedList:对于频繁的插入删除操作,使用此类效率比ArrayList效率高,线程也不安全                                     </span></span><br><span class="line">                           底层采用双向链表存储</span><br><span class="line">           |<span class="comment">----Vector：作为List的古老实现类，线程安全的，效率低;</span></span><br><span class="line">                           底层采用<span class="keyword">Object</span>[]数组存储</span><br><span class="line">           </span><br><span class="line">     |<span class="comment">----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span></span><br><span class="line">           |<span class="comment">----HashSet：作为Set接口主要实现类;线程不安全;可以存null值</span></span><br><span class="line">                         底层采用数组+链表+红黑树</span><br><span class="line">           		|<span class="comment">----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span></span><br><span class="line">                          底层采用数组+双向链表+红黑树</span><br><span class="line">           |<span class="comment">----TreeSet：可以按照添加对象的指定属性，进行排序。</span></span><br><span class="line">                           底层采用红黑树</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-5-Map接口继承树"><a href="#1-5-Map接口继承树" class="headerlink" title="1.5 Map接口继承树"></a>1.5 Map接口继承树</h2><p><img src="/2023/10/07/Java%E9%9B%86%E5%90%88/image-20231007084934588.png"></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储<span class="built_in">key</span>-value对的数据</span><br><span class="line">     |----<span class="keyword">HashMap</span>:作为Map的主要实现类；线程不安全的，效率高；可存储<span class="built_in">key</span>和value可以为<span class="keyword">null</span>,且值（value）可以存在多个<span class="keyword">null</span>，键（<span class="built_in">key</span>）只能出现一个<span class="keyword">null</span>，若<span class="built_in">key</span>中出现多个<span class="keyword">null</span>，其结果是对第一个<span class="keyword">null</span>的值进行覆盖</span><br><span class="line">          |----LinkedHashMap:保证在遍历<span class="built_in">map</span>元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的<span class="keyword">HashMap</span>底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于<span class="keyword">HashMap</span>。</span><br><span class="line">     |----TreeMap:保证照添加的<span class="built_in">key</span>-value对进行排序，实现排序遍历。此时考虑<span class="built_in">key</span>的自然排序或定制排序，底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="keyword">null</span>的<span class="built_in">key</span>和value</span><br><span class="line">          |----Properties:常用来处理配置文件。<span class="built_in">key</span>和value都是<span class="keyword">String</span>类型</span><br></pre></td></tr></table></figure>



<h1 id="二、Collection接口"><a href="#二、Collection接口" class="headerlink" title="二、Collection接口"></a>二、Collection接口</h1><h2 id="2-1-collection接口简介"><a href="#2-1-collection接口简介" class="headerlink" title="2.1 collection接口简介"></a>2.1 collection接口简介</h2><p>   (1)Collection 接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。</p>
<p>（2）JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List实现）。</p>
<p>（3）在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；从JDK5.0增加了泛型之后，Java集合可以记住容器中对象的数据类型。</p>
<h2 id="2-2-collection接口常用方法"><a href="#2-2-collection接口常用方法" class="headerlink" title="2.2 collection接口常用方法"></a>2.2 collection接口常用方法</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、添加</span><br><span class="line"><span class="function"><span class="title">add</span>(<span class="variable"><span class="class">Object</span></span> <span class="variable">obj</span>)</span></span><br><span class="line"><span class="function"><span class="title">addAll</span>(<span class="variable">Collection</span> <span class="variable">coll</span>)</span></span><br><span class="line"><span class="number">2</span>、获取有效元素个数</span><br><span class="line"><span class="variable">int</span> <span class="function"><span class="title">size</span>()</span></span><br><span class="line"><span class="number">3</span>、清空集合</span><br><span class="line"><span class="variable">void</span> <span class="function"><span class="title">clear</span>()</span></span><br><span class="line"><span class="number">4</span>、判断是否为空集合</span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">isEmpty</span>()</span></span><br><span class="line"><span class="number">5</span>、是否包含某个元素</span><br><span class="line"><span class="variable">boolean</span> <span class="function"><span class="title">contains</span>(<span class="variable"><span class="class">Object</span></span> <span class="variable">obj</span>):是通过元素的<span class="variable">equals</span>方法来判断是否是同一个对象</span></span><br><span class="line"><span class="function"><span class="variable">boolean</span> <span class="title">containsAll</span>(<span class="variable">Collection</span> <span class="variable">c</span>):也是调用元素的<span class="variable">equals</span>方法来比较的。用两个两个集合的元素逐一比较</span></span><br><span class="line"><span class="function"><span class="number">6</span>、删除</span></span><br><span class="line"><span class="function"><span class="variable">boolean</span> <span class="title">remove</span>(<span class="variable"><span class="class">Object</span></span> <span class="variable">obj</span>):通过元素的<span class="variable">equals</span>方法判断是否是要删除的那个元素。只会删除找到的第一个元素</span></span><br><span class="line"><span class="function"><span class="variable">boolean</span> <span class="title">removeAll</span>(<span class="variable">Collection</span> <span class="variable">coll</span>):取当前集合的差集</span></span><br><span class="line"><span class="function">取两个集合的交集</span></span><br><span class="line"><span class="function"><span class="variable">boolean</span> <span class="title">retainAll</span>(<span class="variable">Collection</span> <span class="variable">c</span>):把交集的结果存在当前的集合中，不影响<span class="variable">c</span></span></span><br><span class="line"><span class="function"><span class="number">7</span>、集合是否相等</span></span><br><span class="line"><span class="function"><span class="variable">boolean</span> <span class="title">equals</span>(<span class="variable"><span class="class">Object</span></span> <span class="variable">obj</span>)</span></span><br><span class="line"><span class="number">8</span>、转换成对象数组</span><br><span class="line"><span class="variable"><span class="class">Object</span></span> [] <span class="function"><span class="title">toArray</span>()</span></span><br><span class="line"><span class="number">9</span>、获取集合对象的哈希值</span><br><span class="line"><span class="function"><span class="title">hashCode</span>()</span></span><br><span class="line"><span class="number">10</span>、遍历</span><br><span class="line"><span class="function"><span class="title">iterator</span>()：返回迭代器对象，用于集合遍历</span></span><br></pre></td></tr></table></figure>



<h1 id="三、Iterator迭代器接口"><a href="#三、Iterator迭代器接口" class="headerlink" title="三、Iterator迭代器接口"></a>三、Iterator迭代器接口</h1><h2 id="3-1-使用Iterator接口遍历集合元素"><a href="#3-1-使用Iterator接口遍历集合元素" class="headerlink" title="3.1 使用Iterator接口遍历集合元素"></a>3.1 使用Iterator接口遍历集合元素</h2><p>（1）Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。</p>
<p>（2）GOF给迭代器模式的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“空姐”、“火车上的乘务员”。</p>
<p>（3）Collection 接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator（）方法，用以返回一个实现了Iterator接口的对象。</p>
<p>（4）Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。</p>
<p>（5）集合对象每次调用iterator（）方法都能得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>
<h2 id="3-2-Iterator接口的方法"><a href="#3-2-Iterator接口的方法" class="headerlink" title="3.2 Iterator接口的方法"></a>3.2 Iterator接口的方法</h2><p>（1）boolean hasNext（）：判断是否还有下一个元素。</p>
<p>（2）E next（）：操作：指针下移，将下移以后集合位置上的元素返回</p>
<p>（3）void remove（）：删除元素。</p>
<p><strong>注意：</strong></p>
<p>①：在调用it.next（）方法之前必须要调用it.hasNext（）进行检测。若不调用，且下一条记录无效，直接调用it.next（）会抛出NoSuchElementException异常.</p>
<p>②：Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</p>
<p>③：如果还未调用next()或在上一次调用naxt方法之后已经调用了remove方法，再调用remove 都会报IllegalStateException。</p>
<h2 id="3-3-使用foreach循环遍历集合元素"><a href="#3-3-使用foreach循环遍历集合元素" class="headerlink" title="3.3 使用foreach循环遍历集合元素"></a>3.3 使用foreach循环遍历集合元素</h2><p>（1）Java5.0提供了foreach循环迭代访问Collection和数组。</p>
<p>（2）遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</p>
<p>（3）遍历集合的底层调用Iterator完成操作。</p>
<p>（4）foreach还可以用来遍历数组。</p>
<h1 id="四、Collection子接口-List接口"><a href="#四、Collection子接口-List接口" class="headerlink" title="四、Collection子接口-List接口"></a>四、Collection子接口-List接口</h1><h2 id="4-1-List接口概述"><a href="#4-1-List接口概述" class="headerlink" title="4.1 List接口概述"></a>4.1 List接口概述</h2><p>（1）鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p>
<p>（2）List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</p>
<p>（3）List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p>
<p>（4）JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</p>
<h2 id="4-2-List接口方法"><a href="#4-2-List接口方法" class="headerlink" title="4.2 List接口方法"></a>4.2 List接口方法</h2><p>List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="type">void</span> <span class="keyword">add</span>(<span class="type">int</span> <span class="keyword">index</span>,<span class="keyword">Object</span> ele):在<span class="keyword">index</span>位置插入ele元素。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）<span class="type">boolean</span> addAll(<span class="type">int</span> <span class="keyword">index</span>,Collection eles):从<span class="keyword">index</span>位置开始将eles中的所有元素添加进来。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）<span class="keyword">Object</span> <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>):获取指定<span class="keyword">index</span>位置的元素。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）<span class="type">int</span> indexOf(<span class="keyword">Object</span> obj):返回obj在集合中首次出现的位置。</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）<span class="type">int</span> lastIndexOf(<span class="keyword">Object</span> obj):返回obj在集合中末次出现的位置。</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）<span class="keyword">Object</span> remove(<span class="type">int</span> <span class="keyword">index</span>):移除指定<span class="keyword">Index</span>位置的元素，并返回此元素。</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）<span class="keyword">Object</span> <span class="keyword">set</span>(<span class="type">int</span> <span class="keyword">index</span>,<span class="keyword">Object</span> ele):设置指定<span class="keyword">index</span>位置的元素为ele。</span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）List subList(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex):返回从fromIndex到toIndex位置的子集合。</span><br></pre></td></tr></table></figure>



<h2 id="4-3-List实现类之一：ArrayList"><a href="#4-3-List实现类之一：ArrayList" class="headerlink" title="4.3 List实现类之一：ArrayList"></a>4.3 List实现类之一：ArrayList</h2><p>（1）ArrayList 是List接口的典型实现类、主要实现类。</p>
<p>（2）本质上，ArrayList是对象引用的一个“变长”数组。</p>
<p>（3）ArrayList的JDK1.8之前与之后的实现区别？</p>
<pre><code>    JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组

    JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时在创建一个始容量为10的数组。
</code></pre>
<p>（4）Arrays.List(…)方法返回的List集合，既不是ArrayList实例，也不是Vector实例。ArrayList(…)返回值是一个固定长度的List集合。</p>
<h2 id="4-4-List实现类之二：LinkedList"><a href="#4-4-List实现类之二：LinkedList" class="headerlink" title="4.4 List实现类之二：LinkedList"></a>4.4 List实现类之二：LinkedList</h2><p>（1）对于<strong>频繁的插入或删除元素</strong>的操作，建议使用LinkedList类，效率较高。</p>
<p>（2）新增方法：</p>
<pre><code>    void addFirst（Object obj)

    void addLast(Object obj)

    Object getFirst()

    Object getLast()

    Object removeFirst()

    Object removeLast()
</code></pre>
<p>(3)LinkedList：双向链表，内部<strong>没有声明数组</strong>，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置  </li>
<li>next变量记录下一个元素的位置</li>
</ul>
<h2 id="5-5-List实现类之三：Vector"><a href="#5-5-List实现类之三：Vector" class="headerlink" title="5.5 List实现类之三：Vector"></a>5.5 List实现类之三：Vector</h2><p>（1）Vector是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</p>
<p>（2）在各种list中，最好<strong>把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList。Vector总是比ArrayList慢，</strong>所以尽量避免使用。</p>
<p>（3）新增方法：</p>
<pre><code>    void addElement(Object obj)

    void insertElement(Object obj,int index)

    void set ElementAt(Object obj,int index)

    void removeElement(Object obj)

    void removeAllElements()
</code></pre>
<h2 id="5-6-相应面试题"><a href="#5-6-相应面试题" class="headerlink" title="5.6 相应面试题"></a>5.6 相应面试题</h2><p>（1）ArrayList、LinkedList的异同：二者都<strong>线程不安全</strong>，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优先于LinkedList,因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
<p>（2）ArrayList和Vector的区别：ArrayList和Vector几乎是完全相同的，唯一的区别是在于Vector是同步类（synchronized),属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下，大多数的程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。<strong>Vector每次扩容请求其大小的两倍空间，而ArrayList是1.5倍</strong>。Vector还有一个子类Stack。</p>
<h1 id="五-、Collection子接口-Set接口"><a href="#五-、Collection子接口-Set接口" class="headerlink" title="五 、Collection子接口-Set接口"></a>五 、Collection子接口-Set接口</h1><h2 id="5-1-Set接口概述"><a href="#5-1-Set接口概述" class="headerlink" title="5.1 Set接口概述"></a>5.1 Set接口概述</h2><p> （1）Set接口是Collection的子接口，set接口<strong>没有提供额外的方法</strong>。</p>
<p>（2）Set集合不允许包含相同的元素 ，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。</p>
<p>（3）Set判断两个对象是否相同不是使用==运算符，而是根据<strong>equals()方法</strong>。</p>
<h2 id="5-2-Set实现类之一-HashSet"><a href="#5-2-Set实现类之一-HashSet" class="headerlink" title="5.2 Set实现类之一:HashSet"></a>5.2 Set实现类之一:HashSet</h2><p>（1）HashSet概述<br>        ①HashSet是Set接口的典型实现，大多数时候使用Set集合时都是用这个实现类。</p>
<pre><code>    ②HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。

    ③HashSet具有的特点：

            &gt;不能保证元素的排列顺序

            &gt;HashSet不是线程安全的

            &gt;集合元素可以是null

    ④HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相同

    ⑤对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等原则。即：“相等的对象必须具有相等的散列码”。
</code></pre>
<p>（2）向HashSet中添加元素的过程<br>        ①当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值，<strong>通过某种散列函数决定该对象在HashSet底层数组中的存储位置</strong>。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</p>
<pre><code>    ②如果两个元素的hashCode()值相等，会在调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续连接。

    ③如果两个元素的equals()方法返回为true，但他们的hashCode()返回值不相等，hashSet将会把它们存储在不同的位置，但依然可以添加成功。
</code></pre>
<p>（3）重写hashCode()方法的基本原则<br>        ①在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值。</p>
<pre><code>    ②当两个对象的equals()方法比较返回为true时，这两个对象的hashCode()方法的返回值也应相等。
</code></pre>
<p>​        ③对象中用作equals()方法比较的Field，都应该用来计算hashCode值。</p>
<p>（4）重写equals()方法的基本准则<br>        ①当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写hashCode(），根据一个类的equals()方法（改写之后），两个截然不同的实例有可能是在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</p>
<pre><code>    ②因此违反了“相等的对象必须具有相等的散列码”。
   
      ③结论：复写equals方法的时候一般需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算
</code></pre>
<h2 id="5-3-Set实现类之二-LinkedHashSet"><a href="#5-3-Set实现类之二-LinkedHashSet" class="headerlink" title="5.3 Set实现类之二:LinkedHashSet"></a>5.3 Set实现类之二:LinkedHashSet</h2><p>（1）LinkedHashSet是HashSet的子类</p>
<p>（2）LinkedHashSet根据元素的hashCode来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p>
<p><img src="/2023/10/07/Java%E9%9B%86%E5%90%88/image-20231007094910849.png"></p>
<p>（3）LinkedHashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p>
<p>（4）LinkedHashSet不允许集合元素重复</p>
<h2 id="5-4-Set实现类之三-TreeSet"><a href="#5-4-Set实现类之三-TreeSet" class="headerlink" title="5.4 Set实现类之三:TreeSet"></a>5.4 Set实现类之三:TreeSet</h2><p>（1）Tree概述<br>        ①Tree是SortedSet接口的实现类，TreeSet可以确保集合元素除余排序状态。</p>
<pre><code>    ②Tree底层使用红黑树结构存储数据。

    ③新增的方法：（了解）

            &gt;Comparator comparator()                   &gt;Object higher(Object e)

            &gt;Object first()                             &gt;SortedSet subSet(fromElement,toElement)

            &gt;Object last()                             &gt;SortedSet headSet(toElement)

            &gt;Object lower(Object e)             &gt;SortedSet taiSet(fromElement)

    ④Tree两种排序方法：自然排序和定制排序。默认情况下，Tree采用自然排序。

    ⑤TreeSet和后面的TreeMap采用红黑树的存储结构。特点：有序，查询速度比List快。
</code></pre>
<p>（2）排序–自然排序<br>        ①自然排序：Tree会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列</p>
<pre><code>    ②如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口

            &gt;实现Comparable的类必须实现compareTo(Object obj）方法，两个对象即通过        compareTo(Object obj)方法的返回值来比较大小。

    ③Comparable的典型实现：

            &gt;BigDecimal、BigInteger以及所有的数值型对应的包装类：按它们对应的数值大小进行  比较。

            &gt;Character:按字符的unicode值来进行比较。

            &gt;Boolean:true对应的包装类实例大于false对应的包装类实例。

            &gt;String: 按字符中字符的unicode值进行比较。

            &gt;Date、Time:后边的时间、日期比前面的时间、日期大向

    ④向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添 加的所有元素都会调用compareTo()方法进行比较。

    ⑤因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同 一个类的对象。

    ⑥对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通 过 compareTo(Object obj) 方法比较返回值。

    ⑦当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保 证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过 equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。 否则，让人难以理解。
</code></pre>
<p>（3）排序–定制排序<br>        ①TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没 有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照 其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来 实现。需要重写compare(T o1,T o2)方法。</p>
<pre><code>    ②利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表 示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。

    ③要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。

    ④此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常

    ⑤使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。
</code></pre>
<h1 id="六、Map接口"><a href="#六、Map接口" class="headerlink" title="六、Map接口"></a>六、Map接口</h1><h2 id="6-1-Map接口概述"><a href="#6-1-Map接口概述" class="headerlink" title="6.1 Map接口概述"></a>6.1 Map接口概述</h2><p>​        ① Map与Collection并列存在。用于保存具有映射关系的数据:key-value ，Map 中的 key 和 value 都可以是任何引用类型的数据</p>
<p>​        ② Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</p>
<p>​        ③ 常用String类作为Map的“键” ，key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到 唯一的、确定的 value</p>
<p>​        ④ Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和 Properties。其中，HashMap是 Map 接口使用频率最高的实现类</p>
<h2 id="6-2-Map接口常用方法"><a href="#6-2-Map接口常用方法" class="headerlink" title="6.2 Map接口常用方法"></a>6.2 Map接口常用方法</h2><p>​        ① 添加、删除、修改操作：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">Object</span> put(<span class="keyword">Object</span> <span class="built_in">key</span>,<span class="keyword">Object</span> value)：将指定<span class="built_in">key</span>-value添加到(或修改)当前<span class="built_in">map</span>对象中</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">void</span> putAll(Map m):将m中的所有<span class="built_in">key</span>-value对存放到当前<span class="built_in">map</span>中</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">Object</span> remove(<span class="keyword">Object</span> <span class="built_in">key</span>)：移除指定<span class="built_in">key</span>的<span class="built_in">key</span>-value对，并返回value</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">void</span> <span class="built_in">clear</span>()：清空当前<span class="built_in">map</span>中的所有数据</span><br></pre></td></tr></table></figure>



<p>​    ② 元素查询的操作：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)：获取指定<span class="built_in">key</span>对应的value</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">boolean</span> containsKey(<span class="keyword">Object</span> <span class="built_in">key</span>)：是否包含指定的<span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">boolean</span> containsValue(<span class="keyword">Object</span> value)：是否包含指定的value</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">int</span> <span class="built_in">size</span>()：返回<span class="built_in">map</span>中<span class="built_in">key</span>-value对的个数</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">boolean</span> isEmpty()：判断当前<span class="built_in">map</span>是否为空  <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> obj)：判断当前<span class="built_in">map</span>和参数对象obj是否相等</span><br></pre></td></tr></table></figure>



<p>​    ③ 元视图操作的方法：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="javascript"><span class="built_in">Set</span> keySet()：返回所有key构成的<span class="built_in">Set</span>集合</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">Collection values()：返回所有value构成的Collection集合</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript"><span class="built_in">Set</span> entrySet()：返回所有key-value对构成的<span class="built_in">Set</span>集合</span></span><br></pre></td></tr></table></figure>



<h2 id="6-3-Map实现类之一：HashMap"><a href="#6-3-Map实现类之一：HashMap" class="headerlink" title="6.3 Map实现类之一：HashMap"></a>6.3 Map实现类之一：HashMap</h2><p>（1）HashMap概述<br>     ①HashMap是Map接口使用频率最高的实现类。</p>
<p>​    ②允许使用null键和null值，与HashSet一样，不保证映射的顺序。</p>
<p>​    ③所有的key构成的集合是Set：无序的、不可重复的。所以，key所在的类要重写equals()和hashCode（）</p>
<p>​    ④所有的value构成的集合是Collection：无序的、可以重复的。所以，value所在的类要重写equals()</p>
<p>​    ⑤一个key-value构成一个entry</p>
<p>​    ⑥所有的entry构成的集合是Set:无序的、不可重复的</p>
<p>​    ⑦HashMap 判断两个key相等的标准是：两个key通过equals()方法返回true，hashCode值也相等。</p>
<p>​    ⑧HashMap 判断两个value相等的标准是：两个value通过equals()方法返回true。</p>
<h2 id="6-4-Map实现类之二：LinkedHashMap"><a href="#6-4-Map实现类之二：LinkedHashMap" class="headerlink" title="6.4 Map实现类之二：LinkedHashMap"></a>6.4 Map实现类之二：LinkedHashMap</h2><p>（1） LinkedHashMap概述<br>        ①LinkedHashMap是HashMap的子类</p>
<p>​        ②在HashMap存储结构的基础上，使用了一堆双向链表来记录添加元素的顺序</p>
<pre><code>    ③与LinkedHashSet类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-Value对的插入顺序一致 
</code></pre>
<h2 id="6-5-Map实现类之三：TreeMap"><a href="#6-5-Map实现类之三：TreeMap" class="headerlink" title="6.5 Map实现类之三：TreeMap"></a>6.5 Map实现类之三：TreeMap</h2><p>（1）TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于有序状态。</p>
<p>（2）TreeSet底层使用红黑树结构存储数据</p>
<p>（3）TreeMap 的 Key 的排序：</p>
<pre><code>    &gt;自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有 的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException

    &gt;定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口
</code></pre>
<p>（4） TreeMap判断两个key相等的标准：两个key通过compareTo()方法或 者compare()方法返回0。</p>
<h2 id="6-6-Map实现类之四：Hashtable"><a href="#6-6-Map实现类之四：Hashtable" class="headerlink" title="6.6 Map实现类之四：Hashtable"></a>6.6 Map实现类之四：Hashtable</h2><p>（1）Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap， Hashtable是线程安全的。</p>
<p>（2） Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询 速度快，很多情况下可以互用。</p>
<p>（3） 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value </p>
<p>（4）与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</p>
<p>（5）Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</p>
<h2 id="6-7-Map实现类之五：Properties"><a href="#6-7-Map实现类之五：Properties" class="headerlink" title="6.7 Map实现类之五：Properties"></a>6.7 Map实现类之五：Properties</h2><p>（1）Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</p>
<p>（2）存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法</p>
<h1 id="七、总结-开发中如何选择集合实现类"><a href="#七、总结-开发中如何选择集合实现类" class="headerlink" title="七、总结-开发中如何选择集合实现类"></a>七、总结-开发中如何选择集合实现类</h1><p>在开发中，遊择什么集合实现美，主要取决于业务操作特点，然后根据集合安现类特性进行<br>选择，分析如下：<br>1）先判断存储的类型（一组对象或一组键值对）</p>
<p>2）一组对象：Collection接口<br>    允许重复：List<br>    增删多：LinkedList [底层维护了一个双向链表]<br>    改查多：Arraylist[底层维护 Object类型的可变数组]<br>    不允许重复: Set<br>    无序：Hashset[席层是HashMap，维护了一个哈希表 即（数组＋链表＋红黑树）】<br>    排序：TreeSet<br>    插入和取出顺序一致：LinkedHashSet，维护数组＋双向链表</p>
<p>3）一组键值对：Map接口<br>    键无序：HashMap[底层是：哈希表 jdk7：数组＋链表，jdk8：数组＋链表＋红黑树]<br>    键排序：TreeMap<br>    鍵插入和取出順序一致： LinkedHashMap<br>    读取文件 Properties </p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/28/JavaIO%E5%85%A5%E9%97%A8/" rel="prev" title="JavaIO入门">
      <i class="fa fa-chevron-left"></i> JavaIO入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/" rel="next" title="Java多线程与并发">
      Java多线程与并发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">参考文章：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">一、Java集合框架概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%95%B0%E7%BB%84Array%E5%AD%98%E5%82%A8"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 数组Array存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%AD%98%E5%82%A8"><span class="nav-number">2.2.</span> <span class="nav-text">1.2  Java集合类存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 Java集合体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Collection%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 Collection继承树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-Map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-number">2.5.</span> <span class="nav-text">1.5 Map接口继承树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">二、Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-collection%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 collection接口简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-collection%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 collection接口常用方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">三、Iterator迭代器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8Iterator%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 使用Iterator接口遍历集合元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 Iterator接口的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E4%BD%BF%E7%94%A8foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 使用foreach循环遍历集合元素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3-List%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">四、Collection子接口-List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-List%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 List接口概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-List%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 List接口方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%80%EF%BC%9AArrayList"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 List实现类之一：ArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%8C%EF%BC%9ALinkedList"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 List实现类之二：LinkedList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%89%EF%BC%9AVector"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 List实现类之三：Vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E7%9B%B8%E5%BA%94%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 相应面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3-Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.</span> <span class="nav-text">五 、Collection子接口-Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Set%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 Set接口概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Set%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%80-HashSet"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 Set实现类之一:HashSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Set%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%8C-LinkedHashSet"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 Set实现类之二:LinkedHashSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-Set%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%89-TreeSet"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 Set实现类之三:TreeSet</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.</span> <span class="nav-text">六、Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Map%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 Map接口概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Map%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 Map接口常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%80%EF%BC%9AHashMap"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 Map实现类之一：HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%8C%EF%BC%9ALinkedHashMap"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 Map实现类之二：LinkedHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%89%EF%BC%9ATreeMap"><span class="nav-number">7.5.</span> <span class="nav-text">6.5 Map实现类之三：TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E5%9B%9B%EF%BC%9AHashtable"><span class="nav-number">7.6.</span> <span class="nav-text">6.6 Map实现类之四：Hashtable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%BA%94%EF%BC%9AProperties"><span class="nav-number">7.7.</span> <span class="nav-text">6.7 Map实现类之五：Properties</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">七、总结-开发中如何选择集合实现类</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="B3c0me"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">B3c0me</p>
  <div class="site-description" itemprop="description">去爱 去工作</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zcwww6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zcwww6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1311839468@qq.com" title="E-Mail → mailto:1311839468@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">greyArea</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
